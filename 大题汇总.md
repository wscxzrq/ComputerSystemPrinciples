# 大题汇总

## 简答题

### 指令

指令是一串 0 / 1 序列，用来指示 CPU 完成特定的操作

### 指令系统

从具体问题到机器语言程序的每次转换都属于软件的范围，软硬件之间的桥梁就是指令体系结构，简称指令集架构或指令系统。它是软硬件之间接口的完整定义，ISA 定义了一套计算机可以执行的所有指令的集合，每条指令规定了计算机可以执行的操作，操作数的地址与类型，机器语言就是 ISA 规定的指令序列，因此，计算机执行机器语言的过程就是让其一条一条执行指令。

### 说明进位和溢出在概念和应用上的不同

进位：二进制加法运算时向更高位进位，最高位的进位常用于无符号数的加法时判断是否溢出

溢出：两个有符号数进行加减运算的结果超出了给定的取值范围，常用于带符号数运算

### 汉字字符编码有哪三类，简述各类编码的作用，并分别列举一个实际的作用

汉字的编码分为输入码，内码，输出字形码。输入码用于汉字信息的输入，例如拼音码；内码用于汉字信息在计算机内部的存储和处理，比如区位码；输出字形码用于汉字显示，比如字模点阵码

### 简述计算机中有多字节数据存储时，大端和小端存储方式的差异

大端方式是指数据的最高有效字节存放在最小地址单元，最低有效字节存放在最大地址单元

小端方式是指数据的最高有效字节存放在最大地址单元，最低有效字节存放在最小地址单元

### 在浮点数加减法中对阶的目的是什么？对阶的原则是什么

对阶的目的是使参加运算的两个数的阶码相等，以使它们的尾数可以直接相加减。

对阶的原则是小阶向大阶看齐，即小阶的那个数的尾数右移

### 浮点数加减运算需要经过哪几个主要步骤

对阶、尾数相加减、规格化、尾数舍入和溢出判断

### 过程的调用步骤

1. P 将入口参数放到 Q 能访问的地方
1. P 将返回地址存到特定的地方，然后将控制转移到 Q
1. Q 保存 P 的现场，并为自己的非静态局部变量分配空间
1. 执行 Q 的过程体
1. Q 恢复 P 的现场，并释放局部变量所占空间
1. Q 取出返回地址，将控制转移到 P

### i386 System V ABI对 struct 结构体数据的规则

1. 结构体的对齐方式跟它里面对齐要求**最严格的成员**相同。
1. 每个成员都要按照它自己的对齐要求，放到**满足对齐要求的最小位置**，这可能会导致**内部空隙**。
1. 结构体的总大小必须是**对齐边界的整数倍**，这可能会在结尾部分有**尾部空隙**。

### 可重定位目标文件和可执行目标文件的主要差别

可执行目标文件由链接器将多个可重定位文件组合生成。可重定位文件中的代码和数据地址是相对于起始地址0的，而可执行文件中的地址则按照操作系统的要求，重定位到运行时的虚拟内存中。

与可重定位文件相比，可执行文件的主要区别：

1. ELF头中的 `e_entry` 字段给出程序入口地址，而可重定位文件中这个字段是0。
1. 可执行文件多了 `.init` 节，包含 `_init` 函数，用于程序启动时的初始化。
1. 可执行文件少了 `.rel` 节，因为它的指令和数据已被重定位，不再需要重定位信息。
1. 增加了程序头表，定义了节与虚拟内存段的映射关系。

### 简述全局符号解析的规则

1. `强符号`不能多次定义，否则链接报错
1. 一次`强符号`，多次 `COMMON`符号或`弱符号`，以`强符号`为准
1. 同时出现 `COMMON` 和`弱符号`，以 `COMMON` 符号为准
1. 一个 `COMMON` 符号出现多次，以所占`空间最大`的为准
1. 若是用`-fno-common`选项，则将 `COMMON` 符号当做`强符号`

### CPU 对异常和中断的响应过程可分为三个步骤

保护断点和程序状态、关中断、识别异常和中断事件并转相应处理程序

### I/O 子系统工作过程

CPU在用户态运行用户进程时，遇到系统调用的陷阱指令，会从用户态切换到内核态。切换后，CPU根据EAX寄存器中的系统调用号执行相应的系统调用服务例程。服务例程中，可能需要调用设备驱动程序。设备驱动程序启动外设工作，当外设准备好数据后发出中断请求。CPU响应中断，调出中断服务程序，进行主机与设备间的数据交换。

### 指令ADD R2，(R1)中包含了哪些寻址方式?简述该指令的操作数的形成过程与功能

该指令中包含了寄存器寻址和寄存器间接寻址两种寻址方式。该指令的一个操作数在R2寄存器中，另一个操作数的地址在寄存器R1中：指令功能为将寄存器R2 中的值与内存地址 R1 所指向的值相加，结果存回寄存器 R2

寄存器寻址：操作数直接保存在寄存器中，指令中引用的寄存器就是操作数本身 R2

寄存器间接寻址：寄存器中存储的是一个内存地址，操作数保存在该内存地址所指向的内存单元中 R1

### CPU中设置的程序计数器(PC)和指令译码器(ID)的作用分别是什么?

程序计数器 (PC) 存放即将执行指令的地址，取指令时先将PC的内容发送到地址线；

指令译码器 (ID) 负责解析指令寄存器中的操作码，并生成相应的译码信号，供操作控制部件生成控制信号。

### 什么是程序计数器 PC？为什么要设置 PC 寄存器

程序计数器 PC 是用来存放指令地址信息的，其中存放的是下一条将要执行的指令地址，如果没有 PC 则计算机中的程序就不能自动连续的运行

### 简述补码做加法、减法的运算特点

符号位和数值部分可按相同规则运算，无需单独处理。

补码减法可转为加法运算。

补码加减法是模运算。

### 何谓虚拟存储器？其主要好处是什么

在硬件和操作系统的支持下，将“主存—辅存”结合为一个整体，提供比主存大得多的存储空间，称为虚拟存储器。

虚拟存储器结合了主存的速度和辅存的容量，既快又大，且每位存储的平均成本较低。

### 冯·诺依曼结构的计算机的基本思想包括哪几个方面

采用存储程序的工作方式

由运算器、控制器、存储器、输入设备和输出设备组成

存储器不仅能存放数据，也可以存放指令

计算机内部以二进制形式表示指令和数据

### 磁盘存储设备的技术指标

存储密度

存储容量

平均访问时间

数据传输率

密度、容量、平均访问时间、传输率

### 什么是指令格式？通常情况下一条指令由哪两部分组成

计算机指令编码的格式称为指令格式

通常情况下一条指令格式由操作码、地址码组成

### 溢出

在计算机中，每种数据编码都有其数据表示范围，将运算过程中出现数据超出这个表示范围的现象称为溢出

### 一条指令中应该显式或隐式地给出哪些信息

操作码

源操作数或其地址

结果的地址

下条指令的地址

### 程序状态字中的状态标志是什么？具体有哪些状态标志

作为条件转移类指令的测试条件，供 CPU 进行判断和测试，以决定下一步的操作

进位标志 CF，溢出标志 OF，零标志 ZF，符号标志 SF

### 应用软件

是面向用户应用的功能软件、专门为解决某个应用领域的具体任务而编写的软件

### 统一编址

将I/O设备的每个相关寄存器（如控制寄存器、数据寄存器、状态寄存器等）分配一个存储器地址，通过访问内存指令来访问外围设备，这就是外设接口寄存器与主存统一编址。

## 第一章计算题

**1.设某计算机的时钟频率为2GHz,指令集中有A、B、C三种不同类型的指令，它们的平均CPI分别为1、2、3。某高级语言程序经两个不同的编译程序生成了两种不同的指令序列S1和S2,它们包含的指令情况如下表所示。**

| 指令类别        | A    | B    | C    |
| --------------- | ---- | ---- | ---- |
| 平均 CPI        | 1    | 2    | 3    |
| S1 包含的指令数 | 5    | 4    | 3    |
| S2 包含的指令数 | 4    | 6    | 3    |

**该计算机的峰值MIPS是多少?**

峰值 MIPS 是指在最佳情况下，计算机每秒钟可以执行的百万条指令数。在理想条件下，计算机的 CPI（每条指令的平均时钟周期数）为 1，即每个时钟周期执行一条指令。

$MIPS = \frac{主频}{CPI}$

由于计算机的时钟频率为 2 GHz，CPI = 1，因此峰值 MIPS 计算如下：

$MIPS = \frac{2000}{1} = 2000MIPS$

**S1和S2的执行时间分别是多少?**

$用户 CPU 时间 = \frac{程序总时钟周期数}{时钟频率}$

S1 中各类指令的执行时间：$5 \times 1 + 4 \times 2 + 3 \times 3 = 22$

$\frac{22}{2000} = \frac{22}{2 \times 10^9} = \frac{11}{10^9} = 11ns$

S1 中各类指令的执行时间：$4 \times 1 + 6 \times 2 + 3 \times 3 = 25$

$\frac{25}{2000} = \frac{25}{2 \times 10^9} = \frac{12.5}{10^9} = 12.5ns$

**S1和S2的CPI分别是多少?(结果保留到小数点后2位)**

$CPI = \frac{程序总时钟周期数}{程序总指令条数}$

$S1CPI= \frac{22}{12} \approx 1.83$

$S1CPI= \frac{25}{13} \approx 1.92$



**2.假设某个频繁使用的程序 p 在机器 M1 上运行需要 10s，M1 的时钟频率为 2Ghz。设计人员想开发一台与 M1 具有相同 ISA 的新机器 M2。采用新技术可使M2 的时钟频率增加，但同时也会使CPI 增加。假定程序 P 在 M2 上的时钟周期数是在 M1 上的 1.5 倍，则 M2 的时钟频率至少达到多少才能使程序 p 在 M2 上的运行时间缩短为 6s？**

解：程序 P 在 M1 上执行的时钟周期总数为 $用户 CPU 时间 \times 时钟频率 = 10s \times 2GHz = 20G$

因为程序 P 在 M2 上的时钟周期数是在 M1 上的 1.5 倍所以 $程序 2 的时钟周期总数 = 20G * 1.5 = 30G$

要使程序 P 在 M2上运行时间缩短到 6s，则 M2的时钟频率至少应为$程序总时钟周期数 \div 用户 CPU 时间 = 30G \div 6s = 5GHz$

由此可见，M2 的时钟频率是 M1 的 2.5 倍，但M2 的速度却是 M1 的 1.67 倍 $10s \div 6s = 1.76$

上述例子说明，由于时钟频率的提高可能会对 CPU 结构带来影响，从而使其他性能指标降低，因此，虽然时钟频率提高会加快 CPU 执行程序的速度，但不能保证执行速度有相同倍数的提高

**3.假设某个频繁使用的程序P在机器M1上运行需要20s,M1的时钟频率为1GH。设计人员想开发一台与M1具有相同ISA的新机器M2采用新技术可使M2的时钟频率增加，但同时也会使CPI增加。假定P在M2上执行时的时钟周期数是在M1上的2倍,则M2的时钟频率至少达到多少才能使程序P在M2上的运行时间缩短为4s? **

程序 P 在 M1 上执行的时间周期总数为$用户 CPU 时间 \times 时钟频率 = 20s \times 1GHZ = 20G$

因为程序 P 在 M2 上的时钟周期总数是在 M1 上的两倍所以$程序 2 的时钟周期总数 = 20 \times 2 = 40G$

要使程序 P 在M2 上运行的时间缩短到 4s，则M2 时钟频率应为$程序的总时钟周期数 \div 用户 CPU 时间 = 40G \div 4 = 10GHZ $

由此可见，M2 的时钟频率是 M1 的十倍，但M2 的速度却是 M1 的 $20s \div 4 = 5$倍

上述例子说明，由于时钟频率的提高可能会对 CPU 结构带来影响，从而使其他性能指标降低，因此，虽然时钟频率提高会加快 CPU 执行程序的速度，但不能保证执行速度有相同倍数的提高

**4.假设计算机 M 的指令集中包含 A、B、C 三类指令，其 CPI 分别为 1、2、4。某个程序 P 在 M 上被编译成两个不同的目标代码序列P1和P2，P1 所含 A、B、C三类指令的条数分别为8、2、2，P2 所含 A、B、C三类指令的条数分别为2、5、3。哪个代码序列总指令条数少？哪个执行速度快？它们的 CPI 分别为多少？**

解：P1：$8 + 2 + 2 = 12条$

P2：$2 + 5 + 3 = 10条$

P2 的总指令条数少

P1 的总时钟周期数：$8 \times 1 + 2 \times 2 + 2 \times 4 = 20$

P2的总时钟周期数：$2 \times 1 + 5 \times 2 + 3 \times 4 = 24$

P1执行速度快

CPI 的计算方式为 $程序总时钟周期数 \div 程序总指令条数$

P1CPI：$20 \div 12 = 1.67$

P2CPI：$24 \div 10 = 2.4$

上述例子说明，指令条数少并不代表执行时间短，同样，时钟频率高也不说明执行速度快。在评价计算机性能时，仅考虑单个因素是不全面的，必须三个因素同时考虑



**5.假定某程序 P 编译后生成的目标代码由 A、B、C、D四类指令组成，它们在程序中所占的比例分别为43%、21%、12%、24%，已知它们的 CPI 分别为1、2、2、2。现重新对程序 P 进行编译优化，生成的新目标代码中 A 类指令条数减少了 50%，其他类的指令条数没有变。请回答下列问题**

1. 编译优化前后程序的 CPI 各是多少
1. 假定程序在一台主频为 50MHz 的计算机上运行，则优化前后的 MIPS 各是多少

解：

- A 类指令：比例 43%，CPI 为 1

- B 类指令：比例 21%，CPI 为 2

- C类指令：比例 12%，CPI 为 2

- D 类指令：比例 24%，CPI 为 2

  编译优化前的 CPI 计算公式为：

  $CPI = \sum_{i=1}^n(CPI_i \times F_i) = 程序总时钟周期数 \div 程序总指令条数$

   CPI~before~$= 0.43 \times 1 + 0.21 \times 2 + 0.12 \times 2 + 0.24 \times 2 $

  CPI~before~$= 0.43 + 0.42 + 0.24 + 0.48 = 1.57$

  **编译优化后的 CPI**

  编译优化后，A 类指令减少了50%，其他类指令不变

- A 类指令比例：$43 \div 2 = 0.215$

- B 类指令比例：21%

- C 类指令比例：12%

- D 类指令比例：24%

总指令比例现在是：$0.215 + 0.21 + 0.12 + 0.24 = 0.785$

编译优化后的比例需要重新归一化（使得总比例为 1），各类指令的新比例为：

- A 类指令：$\frac{0.125}{0.785}$
- B 类指令：$\frac{0.21}{0.785}$
- C 类指令：$\frac{0.12}{0.785}$
- D 类指令：$\frac{0.24}{0.785}$

编译优化后的 CPI 计算公式为

CPI~after~ $= \frac{0.125}{0.785} \times 1 + \frac{0.21}{0.785} \times 2 + \frac{0.12}{0.785} \times 2 + \frac{0.24}{0.785} \times 2$

CPI~after~ $= 0.274 \times 1+0.267 \times 2+0.153 \times 2+0.306\times2$

CPI~after~ $= 0.274+0.534+0.306+0.612$

CPI~after~ $= 1.726$



MIPS 计算公式 $ = \frac{主频}{CPI}$

假定程序在一台主频为 50MHz 的计算机上运行。

**编译优化前的MIPS**

MIPS~before~ $= \frac{50}{1.57} = 31.85$

MIPS~after~ $= \frac{50}{1.762} = 28.97$

从 MIPS 数来看，优化后程序执行速度反而变慢了

与定点指令运行速度`MIPS` 相对应的用来表示浮点操作速度的指标是 `MFLOPS`。它表示每秒所执行的浮点运算有多少百万次，它是基于所完成的操作次数而不是指令数来衡量的。类似的浮点操作数还有 `GFLOPS`(10^9^\s)、`TFLOPS`(10^12^次\s) 、`PFLOPS`(10^15^次\s)、`EFLOPS`10^18^次\s



**6.假设某机器的时钟频率为4GHz，程序 P 在 M 上的指令条数为 $8 \times 10^8$，其 CPI 为 1.25，则 P 在 M 上的执行时间是多少？若在 M 上从程序 P 开始启动到执行结束所需时间为 4s，则 P 的用户 CPU 时间所占的百分比是多少**

解：执行时间 = 用户 CPU 时间

根据公式$用户CPU时间 = 时钟周期总数 \div 时钟频率$

$时钟周期总数 = 指令条数 \times CPI$

$用户 CPU 时间 = (8 \times 10^8 \times 1.25)\div 4 \times 10^9$

$= 10 \times 10^8 \div 4 \times 10^9$

$=10 \div 40 $

$=0.25s$

占比 $\frac{0.25}{4} = 6.25$%

**7.写出 z = (x-y)*y 所对应的指令序列**

z=(x-y) * y，x、y 在主存的 5、6号单元，z 存在 7 号单元

格式 R：0000 （送 mov）、0001（加 add）、0010（减 sub）、0011（乘 mul）

格式 M：1110（取 load）、1111（存 store）

| 主存地址 | 主存单元内容 | 内容说明                                     | 指令        |
| :------: | :----------: | -------------------------------------------- | ----------- |
|    0     |  1110 0110   | I1： R[0] $\leftarrow$M[6];  op = 1110 取数  | load r0, 6# |
|    1     |  0000 0100   | I2：R[1]$\leftarrow$R[0]; op = 0000 传送     | mov r1,r0   |
|    2     |  1110 0101   | I3：R[0]$\leftarrow$M[5]; op=1110 取数       | load r0,5#  |
|    3     |  0010 0001   | I4：R[0]$\leftarrow$ R[0] - R[1]; op-0010 减 | sub r0,r1   |
|    4     |  0011 0001   | I5：R[0]$\leftarrow$R[0] * R[1];op=1100 乘   | mul r0,r1   |
|    5     |  1111 0111   | I6：M[7]$\leftarrow$R[0];op=1111 存数        | store 7#,r0 |
|    6     |  0001 0001   | 操作数 x = 17                                |             |
|    7     |  0000 0001   | 操作数 y = 1                                 |             |
|    8     |  0000 0000   | 结果为 z，初始值为 0                         |             |

## 第二章计算题

**1.设补码位数为 8，求 1101100 和 -1101100 的补码**

$[X_T]_补 = M + X_T（mod {\kern 5pt} M）$

$[110110]_补 = 2^8 + 110 1100 = 0110 1100(mod {\kern 5pt} 2^8)$

$[-1101100]_补 = 2^8 - 1101100 = 10010100(mod {\kern 5pt} 2^8)$

由于不够 8 位所以前面补 0 `01101100` 取反 `10010011`  然后加 1 `10010100`

 **简便方法：**

X~T~是正的，X~T~的补码就是他自身

X~T~是负的，符号位写 1，数值部分取反，末位+1

**例题：**

已知[X~T~]~补~=1011 0100，求真值 X~T~

  1011 0100 -1 = -100 1100

![image-20240628223757775](image-20240628223757775.png)

$\begin{array}{cccccccc} 1 & 0 & 1 & 1 & 0 & 0 & 1 & 2 \\ - & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ \hline 1 & 0 &1 &1 &0 &0 &1 &1\\ \end{array}$   取相反数-100 1100 

<font color='#EF4444'>二进制减法规则：借 1 当 2，由于第一位减1 不够减所以向第二位借，第二位为 0 无法借向第三位借，第三位为 1 可以借，借给第二位此时第二位变为 2，第二位借给第一位 1，第二位变为 1 第一位变为 2 所以 2-1 = 1 1-0 = 1</font>

**2.已知[X~T~]~补~ = 1 011 0100，求[-X~T~]~补~**

已知补码，先减1 `1 011 0011` 得到真值的反码，取反 `1 100 1100`得到真值，求该真值取负的补码，符号位由负的变为正的 `0 100 1100`

**把十进制数 10.25 转换成单精度浮点数表示**

**解**：

1. 符号是正号
1. (10)~10~ = (1010)~2~   (0.25)~10~ = (0.01)~2~
1. (10.25)~10~ = (1010.01)~2~
1. $1.01001 \times 2^3$ `01001 尾数` `3 为指数参与计算指数偏移`
1. 3 + 127 = 130 得到指数偏移 转换为二进制 `10000010` 得到阶码
1. 合并符号、阶码、尾数 10.25 为正数 `0` `10000010`（如果不足 8 位前面补 0 补到八位）`01001` （不足 23 位补 0 补满）

**3.把十进制数-0.75转换为单精度浮点数表示**

**解**：

1. 符号是负号 所以用 1 来表示
1. (0)~10~ = (0)~2~ (0.75)~10~ = (11)~2~
1. (0.75)~10~ = (0.11)~2~
1. $1.1 \times 2^{-1}$ `1 尾数` `-1 为指数参与计算指数偏移`
1. -1 + 127 = 126 得到指数偏移 转换为二进制 `01111110` 得到阶码
1. 合并符号、阶码、尾数 -0.75 为负数 `1` `01111110` `1（后面 22 个 0）`

**4.求机器数为 C0A0 0000H 的 IEEE 754 单精度浮点数值**

**解**：

首先将十六进制转换为二进制

`1` `100 0000 1` `010 0000 0000 0000 0000 0000`

可以得到符号位（1 位）为 1 可知该数为负数

 指数位（8 位） (100 0000 1)~2~ = (129)~10~

尾数位（23 位） (010 0000 0000 0000 0000 0000)~2~

组合计算：

1. 该数为负数
1. 129 - 127 = 2 得到指数（如果计算`浮点数表示` <font color='#EF4444'>阶码 = 127 + 指数</font> 如果计算`浮点数值` <font color='#EF4444'>阶 = 指数 - 127</font>）（32 位单精度格式其`基数隐含为 2`）所以表示 2^2^
1. 尾数用源码表示，第一位总为 1，因而可在尾数中默认第一位的 1，称为`隐藏位`，使得单精度格式的 23 位尾数实际上表示了 `24`位有效数字，双精度格式的 52 位尾数实际上表示了 `53 `位有效数字。IEEE 754 规定 `隐藏位 1`的位置在小数点之前
   1. 尾数 (1.01)~2~ 因为后面全为 0 所以无效，转换为 10 进制`1.25`
   1. $1 \times 2^0 + 0 \times 2^{-1} + 1 \times 2^{-2}$
   1. $1 + 0 + \frac{1}{2^{-2}} = 1.25$
1. $1.25 \times 2^2 = 5.0$
1. 根据符号位可以得到该数为负数 所以 -5.0

**5.假定变量 i、f、d 的类型分别是 int、float、double，它们可以取正无穷、负无穷、NaN以外的任意值，判断下面C 语言关系表达式在 32位机器上运行时是否为真**

1. i == (int)(float) i `不是`， 因为 int 的精度比 float 高，当 i 转换为 float 在转换为 int 时有效数字可能丢失 `可能会发生舍入`
1. f == (float)(int) f  `不是`，因为 float 型有小数部分，当 f 转换为 int 在转换为 float 时，小数部分可能丢失`可能会发生溢出`
1. i == (int)(double) i  `是`，double 比 int 有更大的精度和范围，当 i 转换为 double 在转换为 int 时，数值不变
1. f == (float)(double) f `是`，double 比 float 有更大的精度和范围，当 f 转换为 double 在转化为 float 时，数值不变
1. d == (float) d `不是`，double 比 float 有更大的精度和范围，当 d 转换为 float 数值可能会改变`可能发生溢出`
1. f == -(f) `是`，浮点数取负就是简单将数取反
1. (d+f)-d == f `d + f 会发生类型转换变为双精度，不会与单精度相等`

**6.设有一条指令长度为48位，它的编码格式如下:**

| 47:40  | 39:32    | 31:16  | 15:0   |
| ------ | -------- | ------ | ------ |
| 操作码 | 寻址特征 | 位移量 | 立即数 |

**操作码 `34H`** 位于最左边（位 47:40），是最高字节。

**立即数 `1200H`** 位于最右边（位 15:0），是最低字节。

其中，操作码为34H，寻址特征为18H,位移量为0215H,立即数为1200H。将该指令分别按照小端方式和大端方式存储在2000号开始的按字节编址的存储单元中。试画出如下表格，并将结果用十六进制数填入。

给定的指令格式是48位长，分为4个部分：操作码（8位）、寻址特征（8位）、位移量（16位）和立即数（16位）。数据的存储需要按照**小端方式**和**大端方式**进行。小端存储意味着低字节优先（低位字节存储在低地址），大端存储则是高字节优先（高位字节存储在低地址）。

我们先根据给定的指令部分进行分解：

- 操作码：34H （8位）
- 寻址特征：18H （8位）
- 位移量：0215H （16位）
- 立即数：1200H （16位）

总的指令长度是6个字节。

小端存储方式：

小端方式将**低位字节**放在**低地址**，即：

1. 立即数 `1200H`：低位 `00H` 存在 `2000` 地址，高位 `12H` 存在 `2001` 地址
1. 位移量 `0215H`：低位 `15H` 存在 `2002` 地址，高位 `02H` 存在 `2003` 地址
1. 寻址特征 `18H` 存在 `2004` 地址
1. 操作码 `34H` 存在 `2005` 地址

大端存储方式：

大端方式将**高位字节**放在**低地址**，即：

1. 操作码 `34H` 存在 `2000` 地址
1. 寻址特征 `18H` 存在 `2001` 地址
1. 位移量 `0215H`：高位 `02H` 存在 `2002` 地址，低位 `15H` 存在 `2003` 地址
1. 立即数 `1200H`：高位 `12H` 存在 `2004` 地址，低位 `00H` 存在 `2005` 地址

指令存储格式（小端和大端）

| 单元地址 | 2000 | 2001 | 2002 | 2003 | 2004 | 2005 |
| -------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 小端     | 00   | 12   | 15   | 02   | 18   | 34   |
| 大端     | 34   | 18   | 02   | 15   | 12   | 00   |

**7.设某机器子长为 32 位，数值位 31 位，符号位 1 位。定点原码小数表示时，最大正数（十进制）为多少？最小负数（十进制）为多少？**

对于定点小数的表示，数值部分（不包括符号位）对应的是一个小于 1 的二进制分数。31 位的二进制小数从小数点开始，依次表示：

$b_1 \times 2^{-1} + b_2 \times 2^{-2} + b_3 \times 2^{-3} + …… b_{31} \times 2^{-31} $

其中$b_1,b_2,b_3 …… b_{31}$是二进制位可以是 0 或 1

**最大正数**：

当符号位为 0 其余 31 位全为 1 时

0.1111……1(31个 1)

转换为二进制

$1 \times 2^{-1} + 1 \times 2^{-2} + 1 \times 2^{-3} + …… 1 \times 2^{-31}$

可以看作是一个等比数列求和，使用等比数列求和公式

$S = 1 - 最小项$

$S = 1 - 2^{-31}$

**最小负数**：

符号位是 1，其余 31 位也是 1

$-(1 \times 2^{-1} + 1 \times 2^{-2} + 1 \times 2^{-3} + …… 1 \times 2^{-31})$

$S = -(1-2^{-31})$

## 第三章 计算题

## 第四章 计算题

## 第五章 计算题

**1.设有一个具有20位地址和32位字长的存储器，问：**

1. 该存储器能存储多少个字节的信息？ 

   存储器有 20 位地址线，能表示的地址空间为 $2^{20}$个存储单元，每个存储单元存储 32 位（即4 字节的信息）

   存储容量为：$2^{20}\times4 = 2^{22}$字节

   $2^{22} = 4MB$

1. 如果存储器由64K×8位的SRAM芯片组成，需要多少片？

   **64K × 8 位**表示每个SRAM芯片有 64K 个存储单元，每个存储单元存储 8 位（即 1 字节）。因此，每片SRAM芯片的存储容量是 **64KB**。

   计算机的总存储容量是$2^{22}$字节，即 4MB（通过(1)问题已经计算出来）。

   $\frac{2^{22}}{2^{16}} = 2^6 = 64 片$

1. 需多少位地址作芯片选择？
   $2^{16} = 64K$，即芯片片内地址线 16 位，存储器地址线为 20 位，故需 4 位地址线作芯片片选选择

**2.设CPU执行一段程序时, cache完成存取次数为1900次,主存完成存取次数为100次。已知 cache的存取周期为2ns,主存的存取周期为30ns求 cache的命中率和平均访存时间。**

Cache 的命中率 = $\frac{命中次数}{程序总访问次数}$

完成存取次数 1900

读取内存次数 100

总访问次数 = 1900 + 100 = 2000

Cache 的命中率 = $\frac{1900}{2000} = 0.95$

cpu Cache 到主存的平均访问时间 = $T_c + (1 -  p) \times T_m$ = Cache 存取周期 + 未命中率 * 主存存取周期

$2 + (1-0.95) \times 30$

$2 + 0.05 \times 30$

$2 + 1.5 = 3.5ns$

**3.设有一个存储器,其地址寄存器有16位,已知每个存储单元可存放8位二进制数。计算出该存储器的容量。若该存储器全部用于存放汉字信息,每个汉字采用内码方式存人,则该存储器可存入多少个汉字?**

地址寄存器有 16 位，表示该存储器的地址范围为$2^{16}$个存储单元。

每个存储单元存放 8 位（1 字节）数据，因此存储器的总容量为：

$2^{16} \times 8 = 2^6 \times 2^{10} \times 8 = 65536 字节 = 64KB$

每个汉字采用内码方式存储，一般使用 2 个字节（16 位）表示一个汉字。

该存储器可以存储的汉字数量为：

$65536 \div 2 = 32768$个汉字

**4.已知 Cache命中率 h=0.98，已知Cache存取周期为50ns，主存存取周期为200ns，求cache-主存层次的平均访问时间**

cpu Cache 到主存的平均访问时间 = $T_c + (1 -  p) \times T_m$ = Cache 存取周期 + 未命中率 * 主存存取周期

$50 + 0.02  \times 200 = 54ns$

**5.已知Cache系统的效率为85%，平均访问时间为60ns,Cache比主存快5倍，求主存存取周期是多少？**

$T_c + (1 - P) * T_m$

$60 = T_c + (1-0.85) \times 5T_C$

$60 = T_c + 0.15 \times 5T_C$

$60 = T_c + 0.75T_c$

$1.75T_c = 60$

$T_c \approx 34.28ns$

$T_m = 34.28 \times 5 = 171.4ns$

## 第六章 计算题

​    



