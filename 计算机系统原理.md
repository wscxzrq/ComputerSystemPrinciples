# 计算机系统原理

# 第一章 计算机系统概述

## 1.1 计算机基本工作原理

### 1.1.1 冯·诺依曼结构基本思想

**冯·诺伊曼结构** (von Neumann architecture) 是现代计算机设计的基础理念之一，由数学家和物理学家约翰冯·诺伊曼(Joho von Neumann) 提出。其基本思想包含以下几个主要方面：

**存储程序概念：**程序和数据以相同的方式存储在同一存储器中。这意味着计算机可以灵活地读写程序指令和数据，不需要装用的硬件单元分别处理编程和数据操作

分为五大部分：

**控制单元**(Control Unit)：负责解释并执行存储在存储器中的指令

**运算单元**(Arithmetic Logic Unit, ALU)：执行基本的算数和逻辑运算

**存储器**(Memory)：存储程序指令和数据

**输入设备**(input Device)：用于接收外部数据

**输出设备**(Output Device)：用于输出计算结果

**顺序执行**：程序指令按照其在存储器中的顺序逐条执行，除非遇到控制转移指令（入条件跳转指令），这使得程序的流程较为简单和直观

**二进制运算**：使用二进制数据表示所有数据和指令，这简化了物理实现，因为物理电路可以很容易地表示和处理二进制数据（如高/低电压或开/关状态）

**统一存储**：在冯·诺伊曼结构中，存储器中的所有位置都是平等的，没有本质上的区别（如没有程序存储专用区和数据存储专用区之分），这增加了计算机操作的灵活性

这些思想不进影响了最早期的计算机设计，还在今天的大多数计算机系统中得到了继续应用。这种结构使得计算机可以灵活地执行复杂程序、处理不同类型的数据、以及高效地完成各种任务

**冯·诺依曼结构主要部件**

1. 用来存放指令和数据的主存储器，简称**主存或内存**
1. 用来进行算数逻辑运算的部件    ，即**算数逻辑部件**（Arithmetic Logic Unit, ALU），在 `ALU`操作控制信号 `ALUop`的控制下，`ALU`可以对输入端 A 和 B 进行不同的运算，得到结果 F；
1. 用于自动逐条取出指令并进行编译的部件，即`控制元件`（Control Unit,CU），也称`控制器`
1. 用来和用户交互的**输入设备和输出设备** 

**冯·诺依曼结构相关的寄存器**

- 为了临时存放从主存取来的数据或运算的结果，还需要若干**通用寄存器**（Gemeral Purpose Gegiter）组成`通用寄存器组`（GPRs）,`ALU`两个输入端 A 和 B 的数据来自通用寄存器
- ALU 运算的结果会产生标志信息，例如，结果是否为 0（零标志 ZF）、是否为负数（符号标志 SF）等，这些标志信息需要记录在专门的`标志寄存器`中
- 从主存取来的指令需要临时保存在**指令寄存器**(Instruction Register,IR)中
- `CPU `为了自动按序读取主存中的指令，还需要有一个**程序计数器**（Program Counter,PC）,在执行当前指令的过程中，自动计算出下一条指令的地址并送到 PC 中保存。通常把控制部件、运算部件和各类寄存器互连组成的电路称为**中央处理器**(Central Processing Unit, CPU)，简称`处理器`

**冯·诺依曼通用寄存器编号**

CPU 需要从通用寄存器中取数据到 `ALU`运算，或把 `ALU`运算的结果保存到通用寄存器中，因此，需要给每个通用寄存器编号。同样，主存中每个单元也需要编号，称为**主存单元地址**，简称**主存地址**。通用寄存器和主存都属于存储部件，计算机中的存储部件都从 0 开始编号

**冯·诺依曼中的总线**

CUP 为了从主存取指令和存取数据，需要通过传输介质和主存相连，通常把连接不同部件进行信息传输的介质称为**总线**，其中，包含了用于传输`地址信息`、`数据信息`和`控制信息`的`地址线`、`数据线`和`控制线`。CPU 访问主存时，需先将主存地址、读/写命令分别送到总线的地址线、控制线和数据线，然后通过数据线发送或接收数据。CPU 送到地址线的主存地址应先存放在**主存地址存储器**（Memory Address register,MAR）中，发送到或从数据线取来的信息存放在**主存数据寄存器**（MemoryData Register，MDR）中

**冯·诺依曼硬件结构图**

![image-20240603231837772](image-20240603231837772.png)

### 1.1.2 程序和指令的执行过程

`程序`是由一系列`有序`的`指令`组成，用于让计算机执行特定任务或解决特定问题的`集合`。这些指令是用特定的编程语言编写的。程序通常包括`输入`、`处理`和`输出`三个部分。通过将这些指令按照逻辑顺序组织起来，程序可以完成从简单的算数运算到复杂的数据处理和用户交互等各种任务。

**程序的关键特点**：

1. **有序性：**所有指令按照特定顺序执行
1. **确定性：**相同的输入在相同条件下会产生相同的输出
1. **可以移植性：**很多程序可以在多个系统上运行，前提是有先赢的编译器或解释器支持

`指令`是一个单独的命令，指示计算机执行一个特定的操作。指令可以是低级的机器代码，也可以是高级编程语言中的单个语句。在低级编程中，指令通常是二进制格式的，在高级编程语言中，指令则是类似于自然语言的代码行

**指令的关键特点**：

1. **原子性：**每条指令通常代表一个原子的操作或步骤
1. **执行性：**指令是由计算机处理单元直接执行的操作

**程序与指令的区别与联系**

|              程序              |                   指令                   |
| :----------------------------: | :--------------------------------------: |
|         由多个指令组成         |              单个命令或操作              |
|          高级组织形式          |                 基本单位                 |
|        用于完成复杂任务        |          用于执行具体的基本操作          |
|       提现整体逻辑和功能       |         提现具体的运算和操作步骤         |
| 例如：一个计算两个数相加的程序 | 例如：将值从一个寄存器加载到另一个寄存器 |

**冯·诺依曼**结构计算机的功能通过执行程序实现，程序的执行过程就是包含的指令的执行过程。

**指令**（instruction）是用0和 1 表示的一串0/1序列，用来指示 `CPU`完成一个特定的原子操作，例如，

- **取数指令**（load）从`主存`单元中取出数据存放到`通用寄存器`中
- **存数指令**（store）将`通用寄存器`的内容写入`主存单元`
- **加法指令**（add）将两个`通用寄存器`内容相加后送入`结果寄存器`
- **传送指令**（mov）将一个`通用寄存器`的内容送到另一个`通用寄存器`

**定长指令格式**

该模型机采用 8 位定长指令字，即每条指令有 8 位，因此指令寄存器 IR 的宽度为 8 位。指令格式有R 型和 M 型两种

![image-20240603235502817](image-20240603235502817.png)

`op`为操作码字段，`R` 型指令的 `op` 为0000、0001 时，分别定义为寄存器间`传送(mov)`和`加(add)`操作；`M `型指令的 `op `为`1110`和` 1111`，分别定义为`取数(load)`和`存数(store)`，`rs` 和` rt`为通用寄存器编号，`addr`为主存单元地址

R[r]表示编号为 r 的通用寄存器中的内容，M[addr]表示地址为 addr 的主存单元内容，$\leftarrow$表示从右向左传送数据。

指令 1110 0110的功能为 R[0] $\leftarrow$ M[0110] 表示将 6 号主存单元（地址为0110）中的内容取到 0 号寄存器；指令 0001 0001 的功能为 R[0] $\leftarrow$ R[0] + R[1],表示将0 号和 1 号寄存器内容相加的结果送到 0 号寄存器

![image-20240604003648467](image-20240604003648467.png)

`存储程序`工作方式规定，程序执行前，需将程序包含的指令和数据先送入主存，一旦启动程序执行，则计算机必须能够在无须操作人员干预的情况下自动完成逐条指令取出和执行的任务



![image-20240604223928298](image-20240604223928298.png)

如图所示，一个程序的执行就是周而复始执行一条一条指令的过程。每条指令的执行过程：从主存取指令 $\rightarrow$ 对指令进行译码 $\rightarrow$ pc增量（图中的 `PC+1`表示 PC 的内容加上当前这一条指令的长度）$\rightarrow$ 取操作数并执行 $\rightarrow$ 将结果送至主存或寄存器保存

程序执行前，首先将程序的起始地址存放在 PC 中，取指令时，将 PC 的的内容作为地址访问主存。每条指令执行过程中，都需要计算下条指令将要执行指令的主存地址，并送到 PC 中。若当前指令为顺序型指令，则下条指令地址为 PC 的内容加上当前指令的长度；若当前指令为跳转型指令，则下条指令地址为指令中指定的目标地址。当前指令执行完后，根据 PC 的值到主存中取到的是下条将要执行的指令，因而计算机能够周而复始地自动取出并执行一条一条指令

程序首地址（即指令 I1 所在地址）为 0，因此，程序开始执行时，PC 的内容为 0000.根据程序执行流程，该程序运行过程中，所执行的指令顺序为 I1 $\rightarrow$ I2 $\rightarrow$ I3 $\rightarrow$ I4 $\rightarrow$ I5

**实现 z = x + y 功能的每条指令执行过程**

| 指令阶段   | I1:1110 0110             | I2: 0000 0100            | I3: 1110 0101            | I4: 0001 0001                                 | I5: 1111 0111            |
| ---------- | ------------------------ | ------------------------ | ------------------------ | --------------------------------------------- | ------------------------ |
| 取指令     | IR $\leftarrow$ M[0000]  | IR $\leftarrow$ M[0001]  | IR $\leftarrow$ M[0010]  | IR $\leftarrow$ M[0001]                       | IR $\leftarrow$ M[0100]  |
| 指令译码   | op=1110，取数            | op=0000，传送            | op=1110，取数            | op=0001，加                                   | op=1111，存              |
| PC 增量    | PC $\leftarrow$ 0000 + 1 | PC $\leftarrow$ 0001 + 1 | PC $\leftarrow$ 0010 + 1 | PC $\leftarrow$ 0011 + 1                      | PC $\leftarrow$ 0100 + 1 |
| 取数并执行 | MDR $\leftarrow$ M[0110] | A $\leftarrow$ R[0]、mov | MDR $\leftarrow$ M[0101] | A $\leftarrow$ R[0]、B $\leftarrow$ R[1]、add | MDR $\leftarrow$ R[0]    |
| 送结果     | R[0] $\leftarrow$ MDR    | R[1] $\leftarrow$ F      | R[0] $\leftarrow$ MDR    | R[0]$\leftarrow$ F                            | M[0111] $\leftarrow$ MDR |
| 执行结果   | R[0] = 33                | R[1] = 33                | R[0] = 16                | R[0]= 33 + 16 = 49                            | M[7] = 49                |

**解读：**指令 I1 存放在第 0 单元，故取指令操作为 IR $\leftarrow$ M[0000]，表示将主存 0 单元中的内容取到指令寄存器 IR 中，故取指令阶段结束时，IR 中内容为 `1110 0110`；然后，将高 4 位 `1110`（op字段）送到控制部件进行指令译码；同时控制 PC 进行`+1`操作，PC 中内容变为 `0001`；因为是取数指令，所以控制器产生`主存读`控制信号 `Read`，并控制在取数并执行阶段将 `Read` 信号送控制线，将指令后 4 位的 `0110（addr 字段）`作为主存地址送 `MAR` 并自动送地址线，经过一段时间后，主存将 `0110`（6#）单元中的 `33`（变量 y）送到数据线并自动存储在 `MDR` 中；最后由控制器将 `MDR` 内容送至 `0 `号通用寄存器，因此，指令`I1` 的执行结果为 `R[0]=33`

其他指令的执行过程类似。程序最后执行的结果为主存 0111（7#）单元内容（变量 z）变为 49，即 M[7]=49

## 1.2 程序的开发与运行

现代通用计算机都采用`存储程序`工作方式，需要计算机完成的任何任务都应先表示为一个程序。首先，应将应用问题（任务）转化为`算法（Algorithm）`描述，使得应用问题的求解变成流程化的清晰步骤，并能确保步骤是有限的。任何一个问题可能有多个求解算法，需要进行算法分析以确定哪种算法在时间和空间上能够得到优化。其次，将算法转换为用编程语言描述的程序，这个转换通常是手工进行的，也就是说，需要程序员进行程序设计。`程序设计语言（Programming Language）`与自然语言不同，它有严格的执行顺序，不存在二义性，能够唯一地确定计算机执行指令的顺序

### 1.2.1 程序设计语言和翻译程序

程序设计语言可以按照不同抽象层、不同适用领域、不同描述结构等分为多种类型，目前大约由上千种程序设计语言，从抽象层次上来分，可以分成高级语言和低级语言两类。

使用特定计算机规定的指令格式而形成的 0/1 序列称为`机器语言`，计算机能够理解和执行的程序称为`机器代码`或`机器语言程序`，其中每条指令都由 0 和 1 组成，称为`机器指令`

最早人们采用机器语言编写程序。机器语言程序的可读性很差，也不易记忆，给程序员的编写和阅读带来极大的困难。因此，热门引入了一种机器语言的符号表示语言，通过简短的英文符号和机器指令建立对应关系，以方便程序员编写和阅读程序。这种语言称为`汇编语言（Assembl yLanguage）`，机器指令对应的符号表示称为`汇编指令`

汇编指令和机器指令一一对应，每条汇编指令表示的功能与对应的机器指令功能完全相同，因而汇编指令和及其指令都与特定的机器结构有关，因此汇编语言和机器语言都属于`低级语言`，他们统称为`机器级语言`

因为每条指令的功能非常简单，所以使用机器级语言描述程序功能时，需描述的细节很多，不仅程序设计工作效率很低，而且同一个程序不能在不同机器上运行。为此，程序员多采用高级程序设计语言编写程序。`高级程序设计语言（High Level Programming Language）`简称`高级编程语言`

因为计算机无法直接理解和执行高级编程语言程序，因而需要将高级语言程序转换成机器语言程序。这个转换过程通常由计算机自动完成，进行这种转换的软件统称为`翻译程序（Translator）`，被翻译的语言和程序分别称为`源语言`和`源程序`，翻译生成的语言和程序分别称为`目标语言`和`目标程序`

**翻译程序有以下三类：**

1. **汇编程序（Assembler）：**也称`汇编器`。用于将汇编语言源程序翻译成机器语言目标程序
1. **解释程序（Interpreter）**：也称`解释器`。用于将源程序中的语句按其执行顺序逐条翻译成机器指令并立即执行
1. **编译程序（Compiler）**：也称`编译器`。用于将高级语言源程序翻译成汇编语言或机器语言目标程序

### 1.2.2 从源程序到可执行文件

```c
#include <stdio.h>

int main () {
  printf("hello,world\n");
}
```

hello.c 在计算机中以 `ASCII 码`的方式存放，第一个字节的值是 35 代表字符`#`，通常把用 ASCII 码或汉字字符表示的文件称为`文本文件（Text File）`,源程序文件都是文本文件，是可显示和可读的

将 hello.c 进行预处理、编译、汇编和链接，最终生成可执行目标文件

例如在 UNIX 系统中，可用 GCC 编译驱动程序进行处理

```shell
unix > gcc -o hello hello.c

最前面的 unix> 为`shell 命令行解释器` 的命令行提示符，`gcc`为 GCC 编译驱动程序名，`-o` 表示后面为输出文件名，hello.c 为要处理的源程序
```

![image-20240605221508303](image-20240605221508303.png)

1. **预处理阶段：**预处理程序（cpp）对源程序中以字符`#`开头的命令进行处理，例如，将#include命令后面的`.h`开头文件内容嵌入源程序文件中。预处理程序的输出结果还是一个源程序文件，以`.i`为扩展名
1. **编译阶段：**编译程序（ccl）对预处理后的源程序进行编译，生成一个汇编语言源程序文件，以.s为扩展名，例如，hello.s 是一个汇编语言程序文件。因为汇编语言与具体的机器结构有关，所以对同一台机器来说，不管什么高级语言，编译转换后的输出结果都是同一种机器语言对应的汇编语言源程序
1. **汇编阶段：**汇编程序（as）对汇编语言源程序进行汇编，生成一个`可重定位目标文件（relocatable object file）` ，以.o 为扩展名，例如，hello.o 是一个可重定位目标文件。它是一种`二进制文件（binary file）`，因为其中的代码已经是机器指令，数据以及其他信息也都是用二进制表示的，所以它是不可读的，也即打开显示出来的是乱码
1. **链接阶段：**链接程序（ld）将多个可重定位目标文件和标准函数库中的可重定位目标文件合并成为一个`可执行目标文件（executable object file ）`，可执行目标文件简称可执行文件。本例中，链接器将hello.o和标准库函数printf()所在的可重定位目标模块printf.o进行合并，生成可执行文件hello.

### 1.2.3 可执行文件的启动和执行

![image-20240605232217960](image-20240605232217960.png)

## 练习 

1. 用于存放计算机指令和数据的临时存储器是`主存储器`

1. 计算机最基本运算单位是 `位/bit`

1. 在计算机系统中，`控制器`是让计算机按照事先编制好的指令序列来完成各种操作的

1. 在计算机系统中，`运算器`负责对信息进行运算处理

1. 计算机操作原理中`指令周期`是指`一条指令从开始执行到执行完毕的时间`

1. 请简要介绍一下计算机的工作原理

   1. 输入阶段，用户通过输入设备将需要处理的数据输入到计算机中
   1. 存储阶段，计算机将输入的数据暂时存放在主存储器中
   1. 运算阶段，计算机通过运算器对存储器中的数据进行运算处理
   1. 输出阶段，计算机将处理完的数据通过输出设备输出给用户

1. 写出 z = (x-y)*y 所对应的指令序列

   z=(x-y) * y，x、y 在主存的 5、6号单元，z 存在 7 号单元

   格式 R：0000 （送 mov）、0001（加 add）、0010（减 sub）、0011（乘 mul）

   格式 M：1110（取 load）、1111（存 store）

| 主存地址 | 主存单元内容 | 内容说明                                     | 指令        |
| :------: | :----------: | -------------------------------------------- | ----------- |
|    0     |  1110 0110   | I1： R[0] $\leftarrow$M[6];  op = 1110 取数  | load r0, 6# |
|    1     |  0000 0100   | I2：R[1]$\leftarrow$R[0]; op = 0000 传送     | mov r1,r0   |
|    2     |  1110 0011   | I3：R[0]$\leftarrow$M[5]; op=1110 取数       | load r0,5#  |
|    3     |  0010 0001   | I4：R[0]$\leftarrow$ R[0] - R[1]; op-0010 减 | sub r0,r1   |
|    4     |  0011 0001   | I5：R[0]$\leftarrow$R[0] * R[1];op=1100 乘   | mul r0,r1   |
|    5     |  1111 0111   | I6：M[7]$\leftarrow$R[0];op=1111 存数        | store 7#,r0 |
|    6     |  0001 0001   | 操作数 x = 17                                |             |
|    7     |  0000 0001   | 操作数 y = 1                                 |             |
|    8     |  0000 0000   | 结果为 z，初始值为 0                         |             |

![image-20240606004004649](image-20240606004004649.png)







# 第二章 数据的表示和运算

# 第三章 程序的转换及机器级表示

# 第四章 可执行文件的生成与加载执行

# 第五章 程序的存储访问

# 第六章 程序中的 I/O 操作实现
